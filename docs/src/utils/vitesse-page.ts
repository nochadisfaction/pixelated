import type { ContentConfig, SchemaContext } from 'astro:content'
import type { VitessePagesEntry } from './routing'
import type { TocHeading } from './toc'
import type { Prettify, RemoveIndexSignature } from './types'
import type { VitesseConfig, VitesseUserConfig } from './user-config'

import { z } from 'astro/zod'

import project from 'virtual:vitesse/project-context'
import config from 'virtual:vitesse/user-config'
import { getCollectionPathFromRoot } from '../loaders'
import { pagesSchema } from '../schema'
import { NavBarItemSchema } from '../schemas/navbar'
import { parseAsyncWithFriendlyErrors, parseWithFriendlyErrors } from './error-map'
import { getNavbarFromConfig } from './navigation'
import { stripLeadingAndTrailingSlashes } from './path'
import {
  getSiteTitle,
  getSiteTitleHref,
  type PageProps,
  type VitesseRouteData,
} from './route-data'
import { slugToLocaleData, urlToSlug } from './slugs'

/**
 * The frontmatter schema for Vitesse pages derived from the default schema for Vitesseâ€™s
 * `pages` content collection.
 * The frontmatter schema for Vitesse pages cannot include some properties which will be omitted
 * and some others needs to be refined to a stricter type.
 */
// eslint-disable-next-line ts/explicit-function-return-type
async function VitessePageFrontmatterSchema(context: SchemaContext) {
  const userPagesSchema = await getUserPagesSchema()
  const schema = typeof userPagesSchema === 'function' ? userPagesSchema(context) : userPagesSchema

  return schema.transform((frontmatter: any) => {
    /**
     * Vitesse pages can only be edited if an edit URL is explicitly provided.
     * The `navBar` frontmatter prop only works for pages in an autogenerated links group.
     * Vitesse pages edit links cannot be autogenerated.
     *
     * These changes to the schema are done using a transformer and not using the usual `omit`
     * method because when the frontmatter schema is extended by the user, an intersection between
     * the default schema and the user schema is created using the `and` method. Intersections in
     * Zod returns a `ZodIntersection` object which does not have some methods like `omit` or
     * `pick`.
     *
     * This transformer only sets the `editUrl` default value and removes the `navBar` property
     * from the validated output but does not appply any changes to the input schema type itself so
     * this needs to be done manually.
     *
     * @see VitessePageFrontmatter
     * @see https://github.com/colinhacks/zod#intersections
     */
    const { ...others } = frontmatter
    return { ...others }
  })
}

/**
 * Type of Vitesse pages frontmatter schema.
 * We manually refines the `editUrl` type and omit the `navBar` property as it's not possible to
 * do that on the schema itself using Zod but the proper validation is still using a transformer.
 * @see VitessePageFrontmatterSchema
 */
type VitessePageFrontmatter =
  Omit<
    z.input<Awaited<ReturnType<typeof VitessePageFrontmatterSchema>>>,
    'navBar'
  >

/** Parse navBar prop to ensure it's valid. */
function validateNavBarProp(navBarProp: VitesseUserConfig['navBar']): VitesseConfig['navBar'] {
  return parseWithFriendlyErrors(
    NavBarItemSchema.array().optional(),
    navBarProp,
    'Invalid navBar prop passed to the `<VitessePage/>` component.',
  )
}

/**
 * The props accepted by the `<VitessePage/>` component.
 */
export type VitessePageProps = Prettify<
  // Remove the index signature from `Route`, omit undesired properties and make the rest optional.
  Partial<Omit<RemoveIndexSignature<PageProps>, 'entry' | 'entryMeta' | 'id' | 'locale' | 'slug'>> &
  // Add the sidebar definitions for a Vitesse page.
  Partial<Pick<VitesseRouteData, 'hasToc'>> & {
    navBar?: VitesseUserConfig['navBar']
    headings?: TocHeading[]
    // And finally add the Vitesse page frontmatter properties in a `frontmatter` property.
    frontmatter: VitessePageFrontmatter
  }
>

/**
 * A pages entry used for Vitesse pages meant to be rendered by plugins and which is safe to cast
 * to a `VitessePagesEntry`.
 * A Vitesse page pages entry cannot be rendered like a content collection entry.
 */
type VitessePagePagesEntry = Omit<VitessePagesEntry, 'id' | 'render'> & {
  /**
   * The unique ID if using the `legacy.collections` for this Vitesse page which cannot be
   * inferred from codegen like content collection entries or the slug.
   */
  id: string
}

export async function generateVitessePageRouteData({
  props,
  url,
}: {
  props: VitessePageProps
  url: URL
}): Promise<VitesseRouteData> {
  const { isFallback, frontmatter, ...routeProps } = props
  const slug = urlToSlug(url)
  const pageFrontmatter = await getVitessePageFrontmatter(frontmatter)
  const id = project.legacyCollections ? `${stripLeadingAndTrailingSlashes(slug)}.md` : slug
  const localeData = slugToLocaleData(slug)
  const navBar = getNavbarFromConfig(
    props.navBar ? validateNavBarProp(props.navBar) : config.navBar,
    url.pathname,
    localeData.locale,
  )
  const pagePagesEntry: VitessePagePagesEntry = {
    id,
    slug,
    body: '',
    collection: 'pages',
    filePath: `${getCollectionPathFromRoot('pages', project)}/${stripLeadingAndTrailingSlashes(slug)}.md`,
    data: {
      ...pageFrontmatter,
    },
  }
  const entry = pagePagesEntry as unknown as VitessePagesEntry
  const entryMeta: VitesseRouteData['entryMeta'] = {
    dir: props.dir ?? localeData.dir,
    lang: props.lang ?? localeData.lang,
    locale: localeData.locale,
  }
  const routeData: VitesseRouteData = {
    ...routeProps,
    ...localeData,
    id,
    entry,
    entryMeta,
    navBar,
    siteTitle: getSiteTitle(localeData.lang),
    siteTitleHref: getSiteTitleHref(localeData.locale),
    slug,
    hasToc: props.hasToc ?? false,
    headings: props.headings ?? [],
  }
  if (isFallback) {
    routeData.isFallback = true
  }
  return routeData
}

/** Validates the Vitesse page frontmatter properties from the props received by a Vitesse page. */
async function getVitessePageFrontmatter(frontmatter: VitessePageFrontmatter): Promise<z.infer<typeof schema>> {
  // This needs to be in sync with ImageMetadata.
  // https://github.com/withastro/astro/blob/cf993bc263b58502096f00d383266cd179f331af/packages/astro/src/assets/types.ts#L32
  const schema = await VitessePageFrontmatterSchema({
    image: () =>
      z.object({
        src: z.string(),
        width: z.number(),
        height: z.number(),
        format: z.union([
          z.literal('png'),
          z.literal('jpg'),
          z.literal('jpeg'),
          z.literal('tiff'),
          z.literal('webp'),
          z.literal('gif'),
          z.literal('svg'),
          z.literal('avif'),
        ]),
      }),
  })

  // Starting with Astro 4.14.0, a frontmatter schema that contains collection references will
  // contain an async transform.
  return parseAsyncWithFriendlyErrors(
    schema,
    frontmatter,
    'Invalid frontmatter props passed to the `<VitessePage/>` component.',
  )
}

/** Returns the user pages schema and falls back to the default schema if needed. */
async function getUserPagesSchema(): Promise<
  NonNullable<ContentConfig['collections']['pages']['schema']>
> {
  const userCollections = (await import('virtual:vitesse/collection-config')).collections
  return userCollections?.pages.schema ?? pagesSchema()
}
